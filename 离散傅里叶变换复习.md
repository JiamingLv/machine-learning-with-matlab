# 离散傅里叶变换复习

## 一、周期序列的离散傅里叶系数DFS

### 1、连续周期函数的傅里叶级数

要说离散傅里叶系数，首先复习一下连续函数的傅里叶级数。连续函数的傅里叶级数将连续的周期函数展开为三角函数和的形式。Wolfram MathWorld中这样进行解释：

> 傅里叶级数是周期函数在正弦和余弦的无穷之和上的拓展。 

考虑一个实函数的周期函数${f(x)}$，周期为$T$，并且确保该函数在有限的区间$P\in[x_0,x_0+T]$是可积的。之后导出傅里叶级数展开的形式如下：
$$
{\begin{equation}
f(t)=\frac{a_0}{2} + \sum_{n=1}^M{a_n\cos{w_n t} + b_n\sin{w_n t}\tag{1.1}}
\end{equation}}
$$
其中，${a_n}$和$b_n$可由周期函数和三角函数积分求得：
$$
{\begin{equation}
\left\{ \begin{array}{l}
a_n = \frac{2}{T}\int_{x_0}^{x_0+T}f(t)\cos{w_n t}\\
b_n = \frac{2}{T}\int_{x_0}^{x_0+T}f(t)\sin{w_n t}\\
w_n = \frac{2\pi n}{T}
\end{array}\right.\tag{1.2}
\end{equation}}
$$
这里引用信号方面的知识可以将$w_n$理解为是基波${w=\frac{2\pi}{T} }$的整数倍。上述展开很好的说明了一个周期函数可以展开为无穷三角函数之和，且三角函数的频率为基频的整数倍。

如果将上述公式$(1.1)$的傅里叶级数形式进行进一步整理，利用三角函数的关系，可化简为：
$$
{\begin{aligned}
f(t) &= \frac{A0}{2} + \sqrt{a_n^2+b_n^2}\sum_{n=1}^{M}\frac{a_n}{\sqrt{a_n^2 + b_n^2}}\cos{w_n t} + \frac{b_n}{\sqrt{a_n^2 + b_n^2}}\sin{w_n t}\\
& = \frac{A_0}{2} + \sum_{n = 1}^{M}A_n\sin(w_n t + \phi) 
\end{aligned} \tag{1.3}}
$$
同时，利用复数和三角函数关系：
$$
{e^{jw} = \cos{w}+i\sin{w}}\tag{1.4}
$$
可以将傅里叶级数化为指数求和的形式：
$$
f(t) = \sum_{n=-T}^{n=T}c_n e^{i \omega_n t}\tag{1.5}
$$
其中$c_n$成为傅里叶系数，可通过积分计算得到：
$$
c_n=\frac{1}{T}\int_{x_0}^{x_0+T} f(t)\cdot e^{\frac{2 \pi n t}{T}}dt\tag{1.6}
$$

### 2、离散周期序列的傅里叶级数

对于离散周期序列的展开式与连续周期序列的形式相似，直接写出其展开式为：
$$
\begin{align}
\tilde{x}[n] &= \sum_{k=-\infty}^{+\infty}c_k e^{j \omega_k n}\\
&= \sum_{k=-\infty}^{+\infty}\tilde{X}_k e^{j(2\pi / N)kn}
\end{align} \tag{1.7}
$$
这里对字符有一些新的表达形式，之后用带波浪线的表示周期序列，例如$\tilde{x}[n]$表示该离散序列是周期的，满足
$$
\tilde{x}[n] = \tilde{x}[n + rN]\tag{1.8}
$$
$r$表示为任意的整数，$N$表示为序列的周期。

在公式$(1.7)$中，我们用$\tilde{X}_k$替换$c_k$来表示傅里叶系数。观察公式中的指数部分，$e_k[n]=e^{j(2\pi/N)kn}$具有周期性，周期为$N$，证明如下：
$$
\begin{align}
e_k[n] &= e_k[n+rN]\\ 
&= e^{j(2\pi/N)k(n+rN)}\\
&= e^{j(2\pi/N)kn}\cdot e^{j 2\pi r}\\
&= e_k[n]
\end{align}\tag{1.9}
$$
因此公式$(1.7 )$根据$e_k[n]$的周期性可缩减$k$的范围，成为一个可加序列，如下所示：
$$
\tilde{x}[n]= \sum_{k=0}^{N-1}\tilde{X}_k e^{j(2\pi / N)kn}\tag{1.10}
$$
为了便于表达（原因在下面的推导就会看到，其实公式的本质是一样的），可将上述公式变为：
$$
\tilde{x}[n]= \frac{1}{N}\sum_{k=0}^{N-1}\tilde{X}_k e^{j(2\pi / N)kn}\tag{1.11}
$$
公式$(1.11)$便是离散周期序列的傅里叶级数展开。之后我们做进一步的推导，将公式两边同时乘以$e^{-j(2\pi/N)r n}$并在两边对$n$求和可以得到：
$$
\sum_{n=0}^{N-1}\tilde{x}[n]e^{-j(2\pi/N)rn}
=\frac{1}{N}\sum_{k=0}^{N-1}\sum_{n=0}^{N-1}\tilde{X}_ke^{j(2\pi/N)n(k-r)}
\tag{1.12}
$$
由于复数求和的特殊性：
$$
\frac{1}{N}\sum_{n=0}^{N-1}e^{j(2\pi/N)n(k-r)}=
\left\{\begin{array}{lcc}
0 & if.k\neq r\\
1 & if.k=r
\end{array}\right.\tag{1.13}
$$
所以公式$(2.6)$可化简为
$$
\sum_{n=0}^{N-1}\tilde{x}[n]e^{-j(2\pi/N)rn}=
\tilde{X}_r\tag{1.14}
$$
为了统一表示，将下标$r$更换为$k$，最终表示为：
$$
\tilde{X}_k=\sum_{n=0}^{N-1}\tilde{x}[n]e^{-j(2\pi/N)kn}
\tag{1.15}
$$
这个式子便是傅里叶系数$\tilde{X}_k$的求解方式，那么将公式$(1.11)$和公式$(1.15)$整理在一起可得
$$
\left\{\begin{array}{l}
\displaystyle \tilde{x}[n]= \frac{1}{N}\sum_{k=0}^{N-1}\tilde{X}_k e^{j(2\pi / N)kn}\\
\displaystyle \tilde{X}_k=\sum_{n=0}^{N-1}\tilde{x}[n]e^{-j(2\pi/N)kn}
\end{array}\right.
\tag{1.16}
$$
这两个式子便组成了离散傅里叶系数（DFS）变换对，可表示为
$$
\tilde{x}[n]{\stackrel{DFS}\longleftrightarrow} \tilde{X}_k
$$
这里$\tilde{x}[n]$和$\tilde{X}_k$均为周期序列，周期为$N$，因此公式$(2.10)$只取了这两个序列的一个周期进行计算。

### 3、典型信号的DFS

#### 3.1、单位脉冲序列

已知单位脉冲序列可表示为：
$$
\tilde{x}[n] = \sum_{k=-\infty}^{+\infty} \delta[n-kn]\tag{1.17}
$$
那么，该单位脉冲序列串的傅里叶系数可以根据公式$(1.16)$计算可得：
$$
\tilde{X}_k = \sum_{n=0}^{N-1}\delta[n]e^{-j(2\pi/N)kn} = 1 \tag{1.18}
$$
之后，利用傅里叶系数的反变换可以得到脉冲序列的另一种表现形式：
$$
\begin{align}
\tilde{x}[n]&=\frac{1}{N}\sum_{k=0}^{N-1}\tilde{X}_k e^{j(2\pi/N)kn}\\
&= \frac{1}{N}\sum_{k=0}^{N-1}e^{j(2\pi/N)kn}
\end{align} \tag{1.19}
$$


#### 3.2、矩形脉冲串

矩形脉冲串便是一个矩形信号在时域上的延拓，这里我们取矩形脉冲串的幅值为1，同时我们取一个矩形信号的长度为4，矩形脉冲串的周期为10，那么矩形脉冲串可以用下图所描述：

![image-20200329082610455](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200329082610455.png)

那么其一个周期的表达式可表示为
$$
{x}[n] = \left\{\begin{array}{l}
1 & if.n<4\\
0 & else
\end{array}\right.
\tag{1.20}
$$
根据公式$(1.17)$可以计算得到矩形脉冲串的傅里叶系数如下：
$$
\begin{align}
\tilde{X}_k &= \sum_{n=0}^{4}e^{-j(2\pi/N)kn}\\
&= \displaystyle\frac{1-e^{-j(2\pi/10)5k}}{1-e^{-j(2\pi/10)k}}\\
&= \displaystyle\frac{e^{j(2\pi/10)(5/2)k}- e^{-j(2\pi/10)(5/2)k}}
{e^{j(2\pi/10)(1/2)k}- e^{-j(2\pi/10)(1/2)k}}e^{-j(2\pi/10)(5/2)k}\cdot e^{j(2\pi/10)(1/2)k}\\
&= \displaystyle \frac{\sin(\pi k/2)}{\sin(\pi k/10)}\cdot e^{-j(4\pi k/10)} 
\end{align} \tag{1.21}
$$
可以看到，矩形脉冲串的离散傅里叶系数是正弦函数形式。

## 二、周期序列的傅里叶变换

根据傅里叶变换的特点我们可以知道，有限长可加的序列才可以进行傅里叶变换，如下所示：
$$
X(e^{j\omega})=\sum_{n=-\infty}^{+\infty}x[n]e^{-j\omega n} \tag{2.1}
$$
但是结合脉冲串的特点，我们将周期序列定义为正比于序列DFS系数的无穷项之和：
$$
\tilde{X}(e^{j\omega})=\frac{2\pi}{N}\sum_{k=-\infty}^{+\infty}\tilde{X}_k\delta(\omega-\frac{2\pi k}{N})\tag{2.2}
$$
我们将周期序列的傅里叶变换用$\tilde{X}(e^{j\omega})$表示，我们可以通过傅里叶逆变换的定义，简要的证明上述的等式：
$$
\begin{align}
\displaystyle \frac{1}{2\pi}\int_{0-\varepsilon}^{2\pi-\varepsilon}\tilde{X}(e^{j\omega})e^{-j\omega n}\,d\omega &=
\displaystyle \frac{1}{2\pi}\int_{0-\varepsilon}^{2\pi-\varepsilon}\frac{2\pi}{N}\sum_{k=-\infty}^{+\infty}\tilde{X}_k\delta(\omega-\frac{2\pi k}{N})e^{-j\omega n}\,d\omega\\&=
\displaystyle \frac{1}{N}\sum_{k=0}^{N-1}\tilde{X}_k e^{j(2\pi/N)kn}\\&=
\displaystyle \tilde{x}[n]
\end{align}
\tag{2.3}
$$
通过公式$(2.3)$我们可以认为$\tilde{X}(e^{j\omega})$是周期序列$\tilde{x}[n]$的傅里叶变换。可见，单位脉冲串的引入可以让周期序列加入到傅里叶变换的框架中。

那么，我们思考，既然周期序列$\tilde{x}[n]$是有限长序列$x[n]$的无线延拓，那么周期序列的傅里叶变换$\tilde{X}(e^{j\omega})$和有限长序列的傅里叶变换$X(e^{j\omega})$有着怎样的关系呢。首先我们可知，周期序列是有限长序列的无限延拓，那么便可以理解为是有限长序列和单位脉冲序列的卷积运算，如下所示：
$$
\begin{align}
\tilde{x}[n] &= x[n]*\tilde{p}[n]\\
&= x[n]*\sum_{r=-\infty}^{+\infty}\delta[n-rN]\\
&= \sum_{r=-\infty}^{+\infty}x[n-rN]
\end{align}
\tag{2.4}
$$
可见，周期序列$\tilde{x}[n]$是有限长序列$x[n]$以$N$为位移长度形成的无穷项序列之和。这里$N$便是周期序列的周期。

之后根据，傅里叶变化的卷积定理，可以得到，周期序列的傅里叶变换计算如下：
$$
\begin{align}
\tilde{X}(e^{j\omega}) &= X(e^{j\omega})\tilde{P}(e^{j\omega})\\
\end{align}
\tag{2.5}
$$
单位脉冲序列的傅里叶变换可分别表示为
$$
\begin{align}
\tilde{P}(e^{j\omega})=\frac{2\pi}{N}\sum_{k=-\infty}^{+\infty}\delta(\omega-\frac{2\pi k}{N})
\end{align}
\tag{2.6}
$$
将公式$(2.6)$代入$(2.5)$中可得：
$$
\begin{align}
\tilde{X}(e^{j\omega}) &= X(e^{j\omega})\cdot \frac{2\pi}{N}\sum_{k=-\infty}^{+\infty}\delta(\omega-\frac{2\pi k}{N})\\
&= \frac{2\pi}{N}\sum_{k=-\infty}^{+\infty} X(e^{j(2\pi/N)k}) \delta(\omega-\frac{2\pi k}{N})
\end{align}
\tag{2.7}
$$
最后我们将公式$(2.2)$和公式$(2.7)$对照来看，可以发现：
$$
\tilde{X}_k = X(e^{j(2\pi/N)k})=X(e^{j\omega})|_{\omega=\frac{2\pi k}{N}}
\tag{2.8}
$$
这里可以看出，**周期序列的离散傅里叶系数是有限长序列的傅里叶变换在频域上等间隔的采样**，这个关系很重要。

我们分别从时域和频域的角度来看到傅里叶系数和傅里叶变换以及周期序列和有限长序列的关系：

**时域上，有限长序列可以从周期序列中恢复，即取周期序列的一个完整周期即可。而周期序列可以用有限长序列和单位脉冲串的卷积来实现。**

**频域上，离散傅里叶系数是傅里叶变换的采样，采样频率为$1/N$。**

同时，与时域采样相似的是，**频域的采样会造成上时域上的延拓**。与时域采样定理相同的是，频域采样也需要一个限定来保证频域的采样不会造成时域上的失真。

为了讨论这个问题，我们看到公式$(2.4)$给出有限长信号延拓的表达式。时域上的延拓本质上就是有限长信号在以$N$为移动单位的序列之和。也就是说，各个序列在移动之后，要保证各个序列没有重叠的部分，才可以保证最后求和的时候不会失真。即保证**单位位移$N$要大于有限长序列的长度**。如下图所示：

![image-20200329124005922](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200329124005922.png)



![image-20200329124021376](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200329124021376.png)

第一幅图展示了一个长度$L$为8的有限长序列。第二幅图展示了当$N=12$，即$N>L$的时候周期序列是没有失真的。第三幅图展示了当$N<L$的时候，周期序列相对于原始有限长序列发生了失真，即无法从时域上恢复原始的有限长信号。

因此，我们可以得出一个频域采样定理：**当在频域对信号的频谱进行采样的时候，要保证采样周期$N$大于有限长信号的长度$L$，才可以保证频域采样后，返回到时域的信号不会发生失真**。

## 三、离散傅里叶变换

### 1、离散傅里叶变换的推导

为什么要提出离散傅里叶变换。原因在于计算机只可以处理有限的、离散的信号。

首先，我们看到有限长序列的傅里叶变换是无穷项之和。离散傅里叶系数是对傅里叶变换的采样，包含了有限长序列的频谱信息，但是一个周期的序列。这两个计算机都无法处理。但是我们可以取离散傅里叶系数的一个周期作为处理的对象，因为这一个周期就包含了原始有限长信号的所有频谱信息。因此我们可以做出如下定义：
$$
X[k]=\left\{\begin{array}{l} 
\tilde{X}_k & 0\leqslant k \leqslant N-1\\
0 & else
\end{array}\right.
\tag{3.1}
$$
这里的$X(k)$便定义为离散傅里叶变换DFT，是DFS系数的一个周期。

那么DFS系数也可以写作：
$$
\tilde{X}[k] = X[(k以N为模)] = X[(k)_N]
\tag{3.2}
$$
根据$x[n]$和$\tilde{x}[n]$的关系：
$$
x[n] = \left\{\begin{array}{l}
\tilde{x}[n] & 0\leqslant n \leqslant N-1\\
0 & else
\end{array}\right.
\tag{3.3}
$$
结合$\tilde{X}[k]$和$\tilde{x}[n]$的关系，即公式$(1.16)$可以最终得到$X[k]$和$x[n]$的关系如下：
$$
\begin{align}
&X[k] = \left\{\begin{array}{l} 
\displaystyle \sum_{n=0}^{N-1}x[n]e^{-j(2\pi/N)kn} & 0\leqslant n \leqslant N-1\\
0 & else
\end{array}\right.\\
&x[n] = \left\{\begin{array}{l} 
\displaystyle \frac{1}{N}\sum_{n=0}^{N-1}X[k]e^{j(2\pi/N)kn} & 0\leqslant n \leqslant N-1\\
0 & else
\end{array}\right.
\end{align}
\tag{3.4}
$$
为了方便书写，之后都将$e^{-j(2\pi/N)kn}$写作$W^{kn}_N$，相应的$e^{j(2\pi/N)kn}$便写做$W_N^{-kn}$，因此可将$X[k]$和$x[n]$简化书写为
$$
\begin{align}
&X[k] =  \displaystyle \sum_{n=0}^{N-1}x[n]W_N^{kn}\\
&x[n] = \displaystyle \frac{1}{N}\sum_{n=0}^{N-1}X[k]W_N^{-kn}
\end{align}
\tag{3.5}
$$
公式$(3.5)$便是有限长序列$x[n]$的离散傅里叶变换和序列$X[k]$的离散傅里叶逆变换。

### 2、DFT实现

既然已经得到了公式，下一步当然是用代码来实现这个算法，这里使用Matlab语言来实现DFT：

```matlab
Fs = 1000;                    % Sampling frequency
T = 1/Fs;                     % Sampling period
L = 1024;                     % Length of signal
t = (0:L-1)*T;                % Time vector
x1 = cos(2*pi*50*t);          % First row wave
plot(t, x1)
r = 2^nextpow2(L);
%% DFT
%-----------自编DFT-------------%
sum = 0;
N = L;
for k = 0:N-1
    for n = 0:N-1
        W = exp(-1i * 2*pi / N);
        sum = sum + x1(n+1) * W^(k*n);
    end
    y(k+1) = sum;
    sum = 0;
end
%-------------------------------%
y1 = fft(x1, r);
%% 显示
f = Fs * (0 : (r/2)) / r;
P = abs(y/N*2);
P1 = abs(y1/N*2);
figure
subplot(2,1,1)
plot(f, P(1:r/2+1))
subplot(2,1,2)
plot(f, P1(1:r/2+1))
```

这里代码进行讲解，第一段中产生了一个信号长度为1000，频率为$10Hz$的余弦序列，并且设定采样频率为$1000Hz$ 。第二段自己编写了一个DFT的实现，本质上是一个简单的二重循环，根据公式$(3.5)$很好实现。最后由于序列是一个实序列，因此DFT产生的**频谱是一个双边谱**，靠近y轴的是正频率谱，远离y轴的负频率谱是由于DFS系数具有周期性的原因导致对折到了这里，如下图所示：

![image-20200329162001907](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200329162001907.png)

所以只取频谱的一半来显示就可以。同时由于傅里叶变换的幅值不是信号原始的幅值，因此需要进行转化，转化的方法为：**第一个频率点乘$\frac{1}{N}$，之后的所有频率点均乘以$\frac{2}{N}$。**最后调整幅值后的频谱如下图所示，同时还将自己编写的DFT与Matlab自带的`fft`函数进行了比较：

![image-20200329161652902](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200329161652902.png)

## 四、快速傅里叶变换

### 1、FFT的推导

我们看到，DFT的实现需要双重循环，当需要处理的点数数目较大时，这样的具有$O(n^2)$时间复杂度的算法处理速度会很慢很慢。而现实生活中处理高速信号的需求越来越高，要求算法的处理时间越来越短，因此需要改进算法来降低时间复杂度。

快速傅里叶变换正是DFT的一种快速算法，简称为FFT。它是利用了多项式分解的方法来加速算法，用多项式来举例说明：
$$
A(x)=\sum_{n=0}^{m-1}a_n x^n\tag{4.1}
$$
假设$m$为2的$n$次幂。那么我们可以给出下面的两个多项式，如下：
$$
\begin{align}
B(x)&=a_0 + a_2x^2 + a_4x^4+...+a_{m-2}x^{m-2}\\
C(x)&=a_1 + a_3x^2 + a_5x^4+...+a_{m-1}x^{m-2}
\end{align}\tag{4.2}
$$
很显然，多项式A可以用多项式B和C来表示如下：
$$
A(x) = B(x) + xC(x)\tag{4.3}
$$
那么多项式A的计算就可以拆分开来计算，每一个多项式计算的次数都是原来的一半，那么同理，多项式B和C可以按照上面的方法继续拆分，每一次计算的次数会变得越来越少，这样的一个过程类似C++语言中的递归。

将上述的方法代入到DFT中，可得到以下推导：
$$
\begin{align}
X[k]&=\sum_{n=0}^{N-1}x[n]W_N^{kn}\\
&=\sum_{r=0}^{(N/2)-1}x[2r]W_N^{2rk}+W_N^k\sum_{r=0}^{(N/2)-1}x[2r+1]W_N^{2rk}
\end{align}\tag{4.4}
$$
根据性质：
$$
W_N^{2rk} = W_{N/2}^{rk}\tag{4.5}
$$
公式$(4.4)$可以化简为
$$
\begin{align}
X[k]&=\sum_{r=0}^{(N/2)-1}x[2r]W_{N/2}^{rk}+W_N^k\sum_{r=0}^{(N/2)-1}x[2r+1]W_{N/2}^{rk}\\
&=G[k]+W_N^kH[k]
\end{align}
\tag{4.6}
$$
从公式$(4.4)$中可以看出每计算一个DFT点，就需要N次复数乘法和N-1次复数加法，因此计算所有的DFT点时，需要$N^2$次复数乘法和$N(N-1)$次复数加法，因此计算时间复杂度就为$O(n^2)$。但是我们从公式$(4.6)$中看到，计算一个点，每一个部分需要$(N/2)$次复数乘法和$(N/2)-1$次复数加法，同时最后的一个部分需要一次复数乘法，把两个部分相加也需要一次复数加法，那么最后计算N个DFT点就需要$N+2(N/2)^2$次乘法和加法（加法为估计值）。那么当N较大时，可以证明$N+2(N/2)^2$要小于$N^2$的计算量的。可见第一次的分解是有效果的！！！

那么根据上述的思路，可将原来的DFT变成下图的计算方式：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407163442116.png" alt="image-20200407163442116" style="zoom:50%;" />

那么可以按照公式$(4.6)$的方法，继续对$G[k]$进行分解，还是按照序号的奇数和偶数进行分解，得到
$$
G[k]=\sum_{l=0}^{(N/4)-1}g[2l]W_{N/4}^{lk}+W_N^k\sum_{l=0}^{(N/4)-1}g[2l+1]W_{N/4}^{lk}
\tag{4.7}
$$
这里的$g[2l]$和$g[2l+1]$便是原来$x[n]$序列的偶数部分的偶数序列和奇数序列，那么N/2点DFT的内部计算图如下：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407164921181.png" alt="image-20200407164921181" style="zoom: 67%;" />

根据性质$(4.5)$可将上述的两幅图结合起来，如下所示：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407165249485.png" alt="image-20200407165249485" style="zoom:67%;" />

上幅图很好的揭示了快速傅里叶变换的计算过程，其中内部的N/4点DFT可用如下图来表示：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407165625564.png" alt="image-20200407165625564" style="zoom:67%;" />

最终，可以得到8点快速傅里叶变化的完全分解图：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407165716621.png" alt="image-20200407165716621" style="zoom:67%;" />

这里的运算分为多级，将N和点不断分解，直到分解为两个点为止，分解的次数就是运算的级数，可表示为$v=log_2 N$。以8点FFT为例，从第一级开始，两个点做DFT运算需要两次复数乘法和两次复数加法，第一级中一共有四组这样的运算，因此第一级有8次复数乘法和复数加法，同理第二级和第三级也是8次。归纳可得，如果有N个点做FFT运算，算法的每一级需要N次复数乘法和加法，一共有$v=log_2 N$级，因此算法的时间复杂度为$O(Nlog_2 N)$是远远优于$O(N^2)$。

但是这简化还没有结束，我们观察前一级求后一级的数值时，其指数总是相差$N/2$。可以利用$W_N^{kn}$的性质，对上述的计算过程进行简化。两级之间的计算如图所示，成为蝴蝶计算。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407173330290.png" alt="image-20200407173330290" style="zoom:67%;" />

根据性质$(4.5)$可以得到
$$
W_N^{r+N/2}=W_N^r \cdot W_N^{N/2}=-W_N^r \tag{4.8}
$$
可以将上图化简为：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407173702994.png" alt="image-20200407173702994" style="zoom: 67%;" />

这样，便可以减少一次复数乘法，又进一步减少了运算量。因此最终可得到8点FFT的完全分解图如下所示：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407173808672.png" alt="image-20200407173808672" style="zoom:67%;" />

这里，我们可以观察到一个特殊的规律，我们将算法输入的8个点做下面的变换处理：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407175249806.png" alt="image-20200407175249806" style="zoom:67%;" />

我们发现，8点FFT的3次抽取得到的输入序列，可以利用二进制倒序的方法得到，这大大简化了输入序列整理的难度，因此整个算法的流程如下图所示：

（女朋友画的必须要放！！！）

<img src="E:\MobileFile\FFT.png" style="zoom: 200%;" />

### 2、FFT的实现

既然FFT的思路已经清晰了，下一步就是要用代码实现FFT，这里要注意的是，**FFT使用的条件输入的点必须是2的整数次幂**，否则不可以使用FFT加速运算。这里我们使用Matlab来实现算法：

```matlab
Fs = 1000;                    % Sampling frequency
T = 1/Fs;                     % Sampling period
L = 1024;                     % Length of signal
t = (0:L-1)*T;                % Time vector
x1 = cos(2*pi*50*t);          % First row wave

Nt = L;
times = log2(Nt);
index = 0:Nt-1;
index_y = zeros(Nt,1);
%------------------自编FFT-------------------%
%倒序
for j = 1:Nt
    for i = 1:times
        index_y(j) = bitshift(index_y(j),1); %y左移一位
        index_y(j) = index_y(j) + rem(index(j),2); %y加上x对2的余数
        index(j) = bitshift(index(j),-1); %x右移一位
    end
end

%FFT
x = zeros(Nt,1);
x(1:Nt) = x1(index_y(1:end)+1);
xs = x;
for i = 1:times
    m = 2^(i-1);
    for j = 1:2^(i):Nt
        for k = j:j+m-1
            ts = xs(k+m) * exp(-1i * 2*pi * (k-j)/2^(i));
            y(m+k) = xs(k) - ts;
            y(k) = xs(k) + ts;
        end
    end
    xs = y;
end
%------------------------------%
r = L;
y1 = fft(x1, r);
%% 显示
f = Fs * (0 : (r-1)) / r;
P = abs(y/L*2);
P1 = abs(y1/L*2);
figure
subplot(2,1,1)
plot(f, P(1:r))
subplot(2,1,2)
plot(f, P1(1:r))
```

和DFT一样，我们使用余弦信号进行计算，并且与Matlab自带的`fft`函数进行对比。运行结果的双边图如下图所示：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200407180322874.png" alt="image-20200407180322874" style="zoom: 80%;" />

可见自己编写的FFT和函数库中计算结果一致，可以说明我们的理论是没有问题的。